\hypertarget{classAdaptivePyramidSwarm}{
\section{AdaptivePyramidSwarm Class Reference}
\label{classAdaptivePyramidSwarm}\index{AdaptivePyramidSwarm@{AdaptivePyramidSwarm}}
}
The \hyperlink{classAdaptivePyramidSwarm}{AdaptivePyramidSwarm} can dynamically change its \hyperlink{classtree}{tree} structure.  


{\tt \#include $<$swarm.h$>$}

Inheritance diagram for AdaptivePyramidSwarm:Collaboration diagram for AdaptivePyramidSwarm:\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
\hyperlink{classAdaptivePyramidSwarm_859220f14a62847f77e03ef895b41673}{AdaptivePyramidSwarm} (\hyperlink{classPSO}{PSO} $\ast$pso\_\-p, int \hyperlink{runpso_8cpp_439227feff9d7f55384e8780cfc2eb82}{size}, int \hyperlink{runpso_8cpp_70b5e28b5bc3d1b63a7435c5fe50b837}{dim}, double \hyperlink{classSwarm_b504e23c39413573e3685a88435f5f85}{min\_\-x}, double \hyperlink{classSwarm_e5075d21be96c1cdf441bc2b612177c1}{max\_\-x}, double \hyperlink{classSwarm_160c79397ea811636e17c0e4d6297729}{min\_\-v}, double \hyperlink{classSwarm_2b0dbde2c275f991580a07a745cb5ade}{max\_\-v}, int \hyperlink{classPyramidSwarm_147496f1f506ee3f2e82cadc9c235baf}{height}, int \hyperlink{classPyramidSwarm_b60c66cd8c7437c9b9abb2016a65e824}{branches}, int \hyperlink{classPyramidSwarm_b45f85f201faea37d41695fe4d3cae04}{swapDelay}, int \hyperlink{classSwarm_6ec8b4463d83af484788490c203ae166}{nrScouts})
\begin{CompactList}\small\item\em Constructor for H-PSO, setting up the swarm and arranging it in a pyramid shape. \item\end{CompactList}\item 
\hyperlink{classAdaptivePyramidSwarm_2369e91955310eb199d661b1a2fb3905}{$\sim$AdaptivePyramidSwarm} ()
\begin{CompactList}\small\item\em The allocated ressources are freed. \item\end{CompactList}\item 
void \hyperlink{classAdaptivePyramidSwarm_1882a87c019b03a0e39cde841f598aaf}{decreaseBranchDegree} ()
\begin{CompactList}\small\item\em Transform the \hyperlink{classtree}{tree} into a \hyperlink{classtree}{tree} with branch degree minus 1. \item\end{CompactList}\end{CompactItemize}
\subsection*{Protected Member Functions}
\begin{CompactItemize}
\item 
int \hyperlink{classAdaptivePyramidSwarm_0d2d0278504ad096f288d8efe5dbf360}{step} (int \hyperlink{runpso_8cpp_b4ae7205573977222eadd0795db193e2}{steps}=1)
\begin{CompactList}\small\item\em The \hyperlink{classAdaptivePyramidSwarm}{AdaptivePyramidSwarm} does \hyperlink{runpso_8cpp_b4ae7205573977222eadd0795db193e2}{steps} steps. \item\end{CompactList}\item 
void \hyperlink{classAdaptivePyramidSwarm_4589069dda7b2f37f71792ac72cd2fa0}{initializeBird} (\hyperlink{classBird}{Bird} $\ast$newBird)
\begin{CompactList}\small\item\em Initialize the particle according to the given initialization strategy. \item\end{CompactList}\item 
void \hyperlink{classAdaptivePyramidSwarm_45c5cc5ee2e6608d899f1b79b8ad170a}{addSubtree} (\hyperlink{classtree}{tree}$<$ \hyperlink{structBirdContainer}{BirdContainer} $>$::iterator)
\begin{CompactList}\small\item\em Insert a new subtree. \item\end{CompactList}\item 
void \hyperlink{classAdaptivePyramidSwarm_bc68c769114ea5cca2acf90938232418}{removeSubtree} (\hyperlink{classtree}{tree}$<$ \hyperlink{structBirdContainer}{BirdContainer} $>$::iterator)
\begin{CompactList}\small\item\em Delete the subtree. \item\end{CompactList}\item 
deque$<$ \hyperlink{structBirdContainer}{BirdContainer} $>$ \hyperlink{classAdaptivePyramidSwarm_95f5eb1095a6dd003b1477290c80780f}{cutSubtree} (\hyperlink{classtree}{tree}$<$ \hyperlink{structBirdContainer}{BirdContainer} $>$::iterator cutNode)
\begin{CompactList}\small\item\em Cut the subtree. \item\end{CompactList}\item 
\hyperlink{classtree}{tree}$<$ \hyperlink{structBirdContainer}{BirdContainer} $>$::iterator \hyperlink{classAdaptivePyramidSwarm_6d57f30724f6a0b7f4f8e5a31ae11f88}{getWorstSubtree} ()
\begin{CompactList}\small\item\em Return the worst subtree. \item\end{CompactList}\item 
\hyperlink{classtree}{tree}$<$ \hyperlink{structBirdContainer}{BirdContainer} $>$::iterator \hyperlink{classAdaptivePyramidSwarm_b16d5e586c4f1732ca51ccdd892fe173}{getWorstSubtree} (\hyperlink{classtree}{tree}$<$ \hyperlink{structBirdContainer}{BirdContainer} $>$::iterator top)
\begin{CompactList}\small\item\em Return the worst subtree below the given node. \item\end{CompactList}\item 
\hyperlink{classtree}{tree}$<$ \hyperlink{structBirdContainer}{BirdContainer} $>$::iterator \hyperlink{classAdaptivePyramidSwarm_e37cf3ca7ce7c3b88f0309ff98cb3052}{getBestSubtree} (\hyperlink{classtree}{tree}$<$ \hyperlink{structBirdContainer}{BirdContainer} $>$::iterator top)
\begin{CompactList}\small\item\em Return the best subtree below the given node. \item\end{CompactList}\item 
\hyperlink{classtree}{tree}$<$ \hyperlink{structBirdContainer}{BirdContainer} $>$::iterator \hyperlink{classAdaptivePyramidSwarm_a7d7026a1e51c961f105b748da828479}{getLRUSubtree} ()
\begin{CompactList}\small\item\em Return the subtree least recently used for providing gbest. \item\end{CompactList}\item 
bool \hyperlink{classAdaptivePyramidSwarm_aa498e09dcf52a80be682a41e6da5563}{noGbestInSubtreeSince} (int threshold)
\begin{CompactList}\small\item\em Return whether a subtree hasn't provided the root node for threshold steps. \item\end{CompactList}\item 
\hyperlink{classtree}{tree}$<$ \hyperlink{structBirdContainer}{BirdContainer} $>$::iterator \hyperlink{classAdaptivePyramidSwarm_6d97c910723d05a6fd4c9aec4187b33b}{getFirstNodeAtDepth} (int depth)
\begin{CompactList}\small\item\em Return an iterator to the first child at the given depth. \item\end{CompactList}\item 
deque$<$ \hyperlink{classtree}{tree}$<$ \hyperlink{structBirdContainer}{BirdContainer} $>$::iterator $>$ \hyperlink{classAdaptivePyramidSwarm_9df13e57e0d7b380ae689a5bc7ae7c7f}{getAllNodesAtDepth} (int depth)
\begin{CompactList}\small\item\em Return all the nodes at the given depth. \item\end{CompactList}\end{CompactItemize}


\subsection{Detailed Description}
The \hyperlink{classAdaptivePyramidSwarm}{AdaptivePyramidSwarm} can dynamically change its \hyperlink{classtree}{tree} structure. 

Depending on the optimization behaviour, the \hyperlink{classAdaptivePyramidSwarm}{AdaptivePyramidSwarm} can add or cut off certain subtrees in the hierarchy. 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classAdaptivePyramidSwarm_859220f14a62847f77e03ef895b41673}{
\index{AdaptivePyramidSwarm@{AdaptivePyramidSwarm}!AdaptivePyramidSwarm@{AdaptivePyramidSwarm}}
\index{AdaptivePyramidSwarm@{AdaptivePyramidSwarm}!AdaptivePyramidSwarm@{AdaptivePyramidSwarm}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}AdaptivePyramidSwarm::AdaptivePyramidSwarm ({\bf PSO} $\ast$ {\em pso\_\-p}, \/  int {\em size}, \/  int {\em dim}, \/  double {\em min\_\-x}, \/  double {\em max\_\-x}, \/  double {\em min\_\-v}, \/  double {\em max\_\-v}, \/  int {\em height}, \/  int {\em branches}, \/  int {\em swapDelay}, \/  int {\em nrScouts})}}
\label{classAdaptivePyramidSwarm_859220f14a62847f77e03ef895b41673}


Constructor for H-PSO, setting up the swarm and arranging it in a pyramid shape. 

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
pso\_\-p}]The \hyperlink{classPSO}{PSO} Algorithm for the parameters used \item[{\em 
size}]The number of birds to create the \hyperlink{classPyramidSwarm}{PyramidSwarm} \item[{\em 
dim}]The dimension of the search space, i.e. the function to be optimized \item[{\em 
min\_\-x}]Lower bound of x dimension, x0 chosen randomly \item[{\em 
max\_\-x}]Upper bound of x dimension, x0 chosen randomly \item[{\em 
min\_\-v}]Lower bound of v dimension, v0 chosen randomly \item[{\em 
max\_\-v}]Upper bound of v dimension, v0 chosen randomly \item[{\em 
height}]The height (levels) of the pyramid \item[{\em 
branches}]How many successors there are on the level below \item[{\em 
swapDelay}]A swap is only allowed every swapDelay steps \item[{\em 
nrScouts}]The number of birds for the scouting swarm \end{description}
\end{Desc}
\hypertarget{classAdaptivePyramidSwarm_2369e91955310eb199d661b1a2fb3905}{
\index{AdaptivePyramidSwarm@{AdaptivePyramidSwarm}!$\sim$AdaptivePyramidSwarm@{$\sim$AdaptivePyramidSwarm}}
\index{$\sim$AdaptivePyramidSwarm@{$\sim$AdaptivePyramidSwarm}!AdaptivePyramidSwarm@{AdaptivePyramidSwarm}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}AdaptivePyramidSwarm::$\sim$AdaptivePyramidSwarm ()}}
\label{classAdaptivePyramidSwarm_2369e91955310eb199d661b1a2fb3905}


The allocated ressources are freed. 



\subsection{Member Function Documentation}
\hypertarget{classAdaptivePyramidSwarm_1882a87c019b03a0e39cde841f598aaf}{
\index{AdaptivePyramidSwarm@{AdaptivePyramidSwarm}!decreaseBranchDegree@{decreaseBranchDegree}}
\index{decreaseBranchDegree@{decreaseBranchDegree}!AdaptivePyramidSwarm@{AdaptivePyramidSwarm}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void AdaptivePyramidSwarm::decreaseBranchDegree ()\hspace{0.3cm}{\tt  \mbox{[}virtual\mbox{]}}}}
\label{classAdaptivePyramidSwarm_1882a87c019b03a0e39cde841f598aaf}


Transform the \hyperlink{classtree}{tree} into a \hyperlink{classtree}{tree} with branch degree minus 1. 

The worst subtree in each level is cut and the nodes are evenly distributed 

Reimplemented from \hyperlink{classSwarm_be7aff8e0df635ac00082fd6cd418356}{Swarm}.\hypertarget{classAdaptivePyramidSwarm_0d2d0278504ad096f288d8efe5dbf360}{
\index{AdaptivePyramidSwarm@{AdaptivePyramidSwarm}!step@{step}}
\index{step@{step}!AdaptivePyramidSwarm@{AdaptivePyramidSwarm}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int AdaptivePyramidSwarm::step (int {\em steps} = {\tt 1})\hspace{0.3cm}{\tt  \mbox{[}protected, virtual\mbox{]}}}}
\label{classAdaptivePyramidSwarm_0d2d0278504ad096f288d8efe5dbf360}


The \hyperlink{classAdaptivePyramidSwarm}{AdaptivePyramidSwarm} does \hyperlink{runpso_8cpp_b4ae7205573977222eadd0795db193e2}{steps} steps. 

Within one iteration the following actions are done for all the particles.\par
 The current position is evaluated, within each neighbourhood the iteration best bird is determined and compared to the bird above, the arrangment is adjusted - the best bird per neighbourhood moves up one level, the current velocity is adjusted to the global best bird and the birds are moved. 

DEBUG 

Reimplemented from \hyperlink{classPyramidSwarm_a9a21f0581b43dc3549fee12d6f2229e}{PyramidSwarm}.\hypertarget{classAdaptivePyramidSwarm_4589069dda7b2f37f71792ac72cd2fa0}{
\index{AdaptivePyramidSwarm@{AdaptivePyramidSwarm}!initializeBird@{initializeBird}}
\index{initializeBird@{initializeBird}!AdaptivePyramidSwarm@{AdaptivePyramidSwarm}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void AdaptivePyramidSwarm::initializeBird ({\bf Bird} $\ast$ {\em newBird})\hspace{0.3cm}{\tt  \mbox{[}protected\mbox{]}}}}
\label{classAdaptivePyramidSwarm_4589069dda7b2f37f71792ac72cd2fa0}


Initialize the particle according to the given initialization strategy. 

The current and best positions are set \hypertarget{classAdaptivePyramidSwarm_45c5cc5ee2e6608d899f1b79b8ad170a}{
\index{AdaptivePyramidSwarm@{AdaptivePyramidSwarm}!addSubtree@{addSubtree}}
\index{addSubtree@{addSubtree}!AdaptivePyramidSwarm@{AdaptivePyramidSwarm}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void AdaptivePyramidSwarm::addSubtree ({\bf tree}$<$ {\bf BirdContainer} $>$::iterator {\em insertNode})\hspace{0.3cm}{\tt  \mbox{[}protected\mbox{]}}}}
\label{classAdaptivePyramidSwarm_45c5cc5ee2e6608d899f1b79b8ad170a}


Insert a new subtree. 

at the specified location \hypertarget{classAdaptivePyramidSwarm_bc68c769114ea5cca2acf90938232418}{
\index{AdaptivePyramidSwarm@{AdaptivePyramidSwarm}!removeSubtree@{removeSubtree}}
\index{removeSubtree@{removeSubtree}!AdaptivePyramidSwarm@{AdaptivePyramidSwarm}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void AdaptivePyramidSwarm::removeSubtree ({\bf tree}$<$ {\bf BirdContainer} $>$::iterator {\em removeNode})\hspace{0.3cm}{\tt  \mbox{[}protected\mbox{]}}}}
\label{classAdaptivePyramidSwarm_bc68c769114ea5cca2acf90938232418}


Delete the subtree. 

starting at (including) the given position. The birds are removed from the \hyperlink{classSwarm_74191c7a473df093f5537f8d6d5ca1a6}{birds} vector. \hypertarget{classAdaptivePyramidSwarm_95f5eb1095a6dd003b1477290c80780f}{
\index{AdaptivePyramidSwarm@{AdaptivePyramidSwarm}!cutSubtree@{cutSubtree}}
\index{cutSubtree@{cutSubtree}!AdaptivePyramidSwarm@{AdaptivePyramidSwarm}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}deque$<$ {\bf BirdContainer} $>$ AdaptivePyramidSwarm::cutSubtree ({\bf tree}$<$ {\bf BirdContainer} $>$::iterator {\em cutNode})\hspace{0.3cm}{\tt  \mbox{[}protected\mbox{]}}}}
\label{classAdaptivePyramidSwarm_95f5eb1095a6dd003b1477290c80780f}


Cut the subtree. 

starting at (including) the given position. The birdContainers are returned. \begin{Desc}
\item[Returns:]All the BirdContainers that were cut \end{Desc}
\hypertarget{classAdaptivePyramidSwarm_6d57f30724f6a0b7f4f8e5a31ae11f88}{
\index{AdaptivePyramidSwarm@{AdaptivePyramidSwarm}!getWorstSubtree@{getWorstSubtree}}
\index{getWorstSubtree@{getWorstSubtree}!AdaptivePyramidSwarm@{AdaptivePyramidSwarm}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf tree}$<$ {\bf BirdContainer} $>$::iterator AdaptivePyramidSwarm::getWorstSubtree ()\hspace{0.3cm}{\tt  \mbox{[}protected\mbox{]}}}}
\label{classAdaptivePyramidSwarm_6d57f30724f6a0b7f4f8e5a31ae11f88}


Return the worst subtree. 

All of the nodes below the root are compared and the worst one is returned \begin{Desc}
\item[Returns:]iterator to the top node of the worst subtree. \end{Desc}
\hypertarget{classAdaptivePyramidSwarm_b16d5e586c4f1732ca51ccdd892fe173}{
\index{AdaptivePyramidSwarm@{AdaptivePyramidSwarm}!getWorstSubtree@{getWorstSubtree}}
\index{getWorstSubtree@{getWorstSubtree}!AdaptivePyramidSwarm@{AdaptivePyramidSwarm}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf tree}$<$ {\bf BirdContainer} $>$::iterator AdaptivePyramidSwarm::getWorstSubtree ({\bf tree}$<$ {\bf BirdContainer} $>$::iterator {\em top})\hspace{0.3cm}{\tt  \mbox{[}protected\mbox{]}}}}
\label{classAdaptivePyramidSwarm_b16d5e586c4f1732ca51ccdd892fe173}


Return the worst subtree below the given node. 

All of the nodes below the given node are compared and the worst one is returned \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em top}]The worst subtree below this node is searched. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]iterator to the top node of the worst subtree. \end{Desc}
\hypertarget{classAdaptivePyramidSwarm_e37cf3ca7ce7c3b88f0309ff98cb3052}{
\index{AdaptivePyramidSwarm@{AdaptivePyramidSwarm}!getBestSubtree@{getBestSubtree}}
\index{getBestSubtree@{getBestSubtree}!AdaptivePyramidSwarm@{AdaptivePyramidSwarm}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf tree}$<$ {\bf BirdContainer} $>$::iterator AdaptivePyramidSwarm::getBestSubtree ({\bf tree}$<$ {\bf BirdContainer} $>$::iterator {\em top})\hspace{0.3cm}{\tt  \mbox{[}protected\mbox{]}}}}
\label{classAdaptivePyramidSwarm_e37cf3ca7ce7c3b88f0309ff98cb3052}


Return the best subtree below the given node. 

All of the nodes below the given node are compared and the best one is returned \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em top}]The best subtree below this node is searched. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]iterator to the top node of the best subtree. \end{Desc}
\hypertarget{classAdaptivePyramidSwarm_a7d7026a1e51c961f105b748da828479}{
\index{AdaptivePyramidSwarm@{AdaptivePyramidSwarm}!getLRUSubtree@{getLRUSubtree}}
\index{getLRUSubtree@{getLRUSubtree}!AdaptivePyramidSwarm@{AdaptivePyramidSwarm}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf tree}$<$ {\bf BirdContainer} $>$::iterator AdaptivePyramidSwarm::getLRUSubtree ()\hspace{0.3cm}{\tt  \mbox{[}protected\mbox{]}}}}
\label{classAdaptivePyramidSwarm_a7d7026a1e51c961f105b748da828479}


Return the subtree least recently used for providing gbest. 

The subtree that hasn't produced the root node for the longest time is returned. \begin{Desc}
\item[Returns:]iterator to the top node of the LRU subtree. \end{Desc}
\hypertarget{classAdaptivePyramidSwarm_aa498e09dcf52a80be682a41e6da5563}{
\index{AdaptivePyramidSwarm@{AdaptivePyramidSwarm}!noGbestInSubtreeSince@{noGbestInSubtreeSince}}
\index{noGbestInSubtreeSince@{noGbestInSubtreeSince}!AdaptivePyramidSwarm@{AdaptivePyramidSwarm}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool AdaptivePyramidSwarm::noGbestInSubtreeSince (int {\em threshold})\hspace{0.3cm}{\tt  \mbox{[}protected\mbox{]}}}}
\label{classAdaptivePyramidSwarm_aa498e09dcf52a80be682a41e6da5563}


Return whether a subtree hasn't provided the root node for threshold steps. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em threshold}]Threshold to the number of steps \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]true, if at least one subtree took longer than threshold. \end{Desc}
\hypertarget{classAdaptivePyramidSwarm_6d97c910723d05a6fd4c9aec4187b33b}{
\index{AdaptivePyramidSwarm@{AdaptivePyramidSwarm}!getFirstNodeAtDepth@{getFirstNodeAtDepth}}
\index{getFirstNodeAtDepth@{getFirstNodeAtDepth}!AdaptivePyramidSwarm@{AdaptivePyramidSwarm}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf tree}$<$ {\bf BirdContainer} $>$::iterator AdaptivePyramidSwarm::getFirstNodeAtDepth (int {\em depth})\hspace{0.3cm}{\tt  \mbox{[}protected\mbox{]}}}}
\label{classAdaptivePyramidSwarm_6d97c910723d05a6fd4c9aec4187b33b}


Return an iterator to the first child at the given depth. 

\hypertarget{classAdaptivePyramidSwarm_9df13e57e0d7b380ae689a5bc7ae7c7f}{
\index{AdaptivePyramidSwarm@{AdaptivePyramidSwarm}!getAllNodesAtDepth@{getAllNodesAtDepth}}
\index{getAllNodesAtDepth@{getAllNodesAtDepth}!AdaptivePyramidSwarm@{AdaptivePyramidSwarm}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}deque$<$ {\bf tree}$<$ {\bf BirdContainer} $>$::iterator $>$ AdaptivePyramidSwarm::getAllNodesAtDepth (int {\em depth})\hspace{0.3cm}{\tt  \mbox{[}protected\mbox{]}}}}
\label{classAdaptivePyramidSwarm_9df13e57e0d7b380ae689a5bc7ae7c7f}


Return all the nodes at the given depth. 

used as a replacement for the fixed depth iterator 

The documentation for this class was generated from the following files:\begin{CompactItemize}
\item 
/home/andrej/workspace/hpso/pso\_\-src/\hyperlink{swarm_8h}{swarm.h}\item 
/home/andrej/workspace/hpso/pso\_\-src/\hyperlink{swarm_8cpp}{swarm.cpp}\end{CompactItemize}
