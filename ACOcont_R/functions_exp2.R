
#######################################################################
#
# functions.R - R implementation of popular test functions for both
#							  continuous and mixed-variable optimization problems
#
# Copyright (c) 2006 by Krzysztof Socha (ksocha@ulb.ac.be)
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#

#######################################################################
#
# Each test function 'foo' is defined as a set of objects described
# below. Each function is considered to be a maximization problem (any
# optimization function may be easily translated to such problem). 
#
# First object (foo.d) is a list that is the domain definition - for each
# variable the variable type must be defined as one of the following:
#   u - unordered descrete variable
#   o - ordered descrete variable
#   x - continuous variable
# Following the variable type, the domain must be defined for each 
# variable. For "u" and "o" variables, all possible values must be 
# specified. For "x" variable the lower and upper bound must be given.
# 
# NOTE: All the descrete variables MUST be defined before any continuous
#       variables!
# 
# Second object (foo.tf) is a function performing the mapping from 
# the values generated by the algorithm to the values from the defined
# earlier domain. Usually for continuous and ordered variables, there 
# is direct mapping, and for unordered - categorical - variables 
# there is a mapping from the index number to the actual value.
# There may be some additional translations or repair mechanisms 
# implemented as well - an option left for the designer. See example
# test functions for details how this may be done.
#
# Third object (foo.f) is the actual obejctive function. The first 
# function that is called must be the foo.tf function in order to mapp 
# the values generated by the algorithm to the actual values from the 
# respective variables' domains. Only then the actual objective function
# value may be calculated and returned.
#
# Finally the last object is a collection of all the previous objects
# of the form:
#		foo <- c(f=foo.f,d=list(foo.d),tf=foo.tf,opt=<optimal value>)
# where the <optimal value> is the known a priori optimal value of the 
# objective function. If the optimal value is not known, it is sufficient
# to specify a high enough value (reminder: all functions are considered
# to be maximization problems).
#
# Below, a template of a function is given. Additional insight into 
# designing test functions may be obtained through the analysis of the 
# (really many) examples provided.
#

#######################################################################
# Test Function Template (FOO)
#
# foo.d <- list(
#		list("<variable type>",<domain>),
#		.
#		.
#		.
#		list("<variable type>",<domain>))
#
#	foo.tf <- function(u,o,x) {
#		<mapping: X <- f(u,o,x)>
#		return(X)
# }
#
# foo.f <- function(u,o,x) {
#		X <- foo.tf(u,o,x)
#		<function body: y <- f(X)>
#		return(y)
# }
#
# foo <- c(f=foo.f,d=list(foo.d),tf=foo.tf,opt=<optimal value>)


# load required utility functions
source("utilities.R")


#######################################################################
# Sphere Model (SM)
#
# Dim:    : n=30
# Domain  : [-5.12,5.12]^n or [-100,100]^n
# Optimum : 0@(0,0)
# Comment : Now defined for n=30, but may be easily modified.

sm.d <- list(
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)))


sm.tf <- function(u,o,x) {
	X <- x
	return(X)
}

sm.f <- function(u,o,x) {
	x <- sm.tf(u,o,x)
  Y <- rep(0,dim(x)[1])
  for (j in 1:(dim(x)[2])) {
    Y <- Y + (x[,j])^2
  }
  return(-Y)
}

sm <- c(f=sm.f,d=list(sm.d),tf=sm.tf,opt=0)


#######################################################################
# Rosenbrock (Rn)
#
# Dim:    : n
# Domain  : [-5,10]^n or [-5,5]^n
# Optimum : 0 @ (1,..,1)
# Comment : Now defined for n=2, but may be easily modified.

rn.d <- list(
	list("x",c(-5,10)),
	list("x",c(-5,10)))


rn.tf <- function(u,o,x) {
	X <- x
	return(X)
}

rn.f <- function(u,o,x) {
	x <- rn.tf(u,o,x)
  Y <- rep(0,dim(x)[1])
  for (j in 1:(dim(x)[2]-1)) {
    Y <- Y + 100*(x[,j]^2-x[,j+1])^2+(x[,j]-1)^2
  }
  return(-Y)
}

rn <- c(f=rn.f,d=list(rn.d),tf=rn.tf,opt=0)



#######################################################################
# Griewank (Gr_n)
#
# Dim:    : n
# Domain  : [-5.12,5.12]^n
# Optimum : 0 @ (0,...,0)
# Comment : Now defined for n=10, but may be easily modified.

gr.d <- list(
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)))

gr.tf <- function(u,o,x) {
	X <- x
	return(X)
}

gr.f <- function(u,o,x) {
	x <- gr.tf(u,o,x)
  Y1 <- rep(0,dim(x)[1])
  Y2 <- rep(1,dim(x)[1])
  for (j in 1:(dim(x)[2])) {
    Y1 <- Y1 + (1/4000)*x[,j]^2
    Y2 <- Y2 * cos(x[,j]/sqrt(j))
  }
  Y <- Y1 - Y2 + 1
  return(-Y)
}

gr <- c(f=gr.f,d=list(gr.d),tf=gr.tf,opt=0)

